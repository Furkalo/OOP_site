<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="../../style.css">
    <link rel="stylesheet" href="../../style_test.css">
    <link rel="stylesheet" href="Lab_1_theory.css">
    <link rel="icon" href="../../Rating/photo/logo.png" type="image/png">
    <title>Не здавайся)</title>
</head>
<body>
    <!-- Overlay for fixed sidebar -->
<div class="sidebar-overlay"></div>

<header>
    <h1>Навчайся через практику! C#</h1>
    <nav>
      <a href="../Theory/Lab_2_theory.html">Теоретичні відомості</a>
      <a href="#">Текст програми та Виконання прикладу</a>
      <a href="../example/Lab_2_example.html">Варіанти завдань</a>
      <a href="../Test/Lab_2_test.html">Контрольні запитання та література</a>
    </nav>
  </header>

<!-- navbar  -->
<div class="navbar">

  <input type="checkbox" class="checkbox" id="click" hidden>

  <!-- sidebar -->
  <div class="sidebar">
      <label for="click">
          <div class="menu-icon">
              <div class="line line-1"></div>
              <div class="line line-2"></div>
              <div class="line line-3"></div>
          </div>
          <p class="sidebar-text">Лаб 2</p>
      </label>
  </div>
  <!-- end of sidebar -->

<!--navigation-->
<nav class="navigation">
  <div class="navigation-header">
    <h1 class="navigation-heading">Робота</h1>
    
  </div>
  
  <ul class="navigation-list">
    <li class="navigation-item">
      <a href="../../Lab_1/Theory/Lab_1.html" class="navigation-link">Лабораторна робота №1</a>
    </li>
    <li class="navigation-item">
      <a href="../Theory/Lab_2_theory.html" class="navigation-link">Лабораторна робота №2</a>
    </li>
    <li class="navigation-item">
      <a href="../../Lab_3/Theory/Lab_3_theory.html" class="navigation-link">Лабораторна робота №3</a>
    </li>
    <li class="navigation-item">
      <a href="../../Lab_4/Theory/Lab_4_theory.html" class="navigation-link">Лабораторна робота №4</a>
    </li>
    <li class="navigation-item">
      <a href="../../Lab_5/Theory/Lab_5_theory.html" class="navigation-link">Лабораторна робота №5</a>
    </li>
    <li class="navigation-item">
      <a href="../../Lab_6/Theory/Lab_6_theory.html" class="navigation-link">Лабораторна робота №6</a>
    </li>
    <li class="navigation-item">
      <a href="https://docs.google.com/document/d/1ptKIyE0X2zUnQkgTMD9tHxrOsJyIKWYG3R9astTJBKA/edit" target="_blank" class="navigation-link">Теми індивідуальних творчих робіт</a>
    </li>
    <li class="navigation-item">
      <a href="../../Rating/index.html" class="navigation-link">Рейтингова система</a>
    </li>
  </ul>
</nav>
</div>
<!-- end of navbar  -->      


  <div class="wrapper">
      <section id='steezy'>
        <h1>Приклади виконання завдань</h1>

        <div class="my-my-list">
            <a class ="a-list" href="#t1">Приклад 1</a><br>
            <a class ="a-list" href="#t2">Приклад 2</a><br>
            <a class ="a-list" href="#t3">Приклад 3</a><br>
            <a class ="a-list" href="#t4">Приклад 4</a><br>
            <a class ="a-list" href="#t5">Приклад 5</a><br>
            <a class ="a-list" href="#t6">Приклад 6</a><br>
          </div>
            <br>
            <br>
            <br>
        <b>1. Робота з масивами в C#</b><br>
        <p>Сума, кількість елементів масиву, пошук максимального значення в масиві
            Розглянемо приклад програми <b>task2_1</b>, яка визначає суму і кількість від'ємних
            елементів, а також максимальний елемент масиву, що складається з 6 цілочисельних
            елементів.</p>
        <p>
            Алгоритм розв’язання задачі такий. Масив позначимо змінною mas. Значення
            елементів масиву mas ініціалізуватимемо при створенні масиву. Для виведення значень
            елементів масиву на консоль використовуватиме цикл з параметром. Зверніть увагу,
            27 що для виведення елементів масиву в один рядок використовується метод
            <span style="color: rgb(3, 180, 180);">Console</span><b>.Write()</b>, а не<span style="color: rgb(3, 180, 180);">Console</span><b>.WriteLine()</b>. Для відокремлення елементів масиву один
            від одного під час виведення використовується символ табуляциії <b>"\t"</b> в методі
            <span style="color: rgb(3, 180, 180);">Console</span><b>.Write()</b>.
        </p>
        <img src="./photo/1_1.png" alt="">
        <h1>Генерація чисел Фібоначчі</h1>
        <p>Розглянемо задачу task2_2 генерації послідовності чисел Фібоначчі, значення
            яких задовольняють таким умовам:</p>
            <img src="./photo/1_2.png" alt="">
        <p>
            Тут k – порядковий номер числа Фібоначчі (нумерація чисел починається від 0),
                f(k) – значення k-го числа Фібоначчі. Цю задачу можна реалізувати з використанням
                масивів. <br>Алгоритм задачі такий:<br>
                • кількість елементів масиву ввести з консолі (клавіатури);<br>
                • створити одновимірний масив вказаної розмірності;<br>
                • визначити перші два числа послідовності Фібоначчі;<br>
                • для елементів послідовності, починаючи з третього, визначити їх
                значення, які дорівнюють сумі двох попередніх елементів;<br>
                • вивести значення елементів послідовності Фібоначчі.
        </p>
            <img src="./photo/1_3.png" alt="">
            <h1>Генерація простих чисел. Алгоритм Ератосфена</h1>
            <p>
                Просте число – це натуральне число, яке має рівно два різних натуральних
                дільники (лише 1 і саме число). Алгоритм пошуку послідовності простих чисел, що не
                перевищують деякого натурального числа n, називається Решетом Ератосфена за
                іменем давньогрецького математика Ератосфена, який вперше запропонував цей
                алгоритм.
            </p>
            <h1>Ідея і загальний опис алгоритму</h1>
            <p>
                Є послідовність цілих чисел від двох до n, що розташовані за зростанням.
                Спочатку в послідовності викреслюють усі числа, що є кратними 2, окрім самого числа
                2. Далі з послідовності, що залишилася після викреслювання чисел, кратних 2,
                29 викреслюють числа, що є кратними 3, окрім самого числа 3. З числами, що є кратними
                4, викреслювання не відбувається через те, що вони вже викреслені. Далі продовжують
                викреслювати числа, що є кратні 5, окрім самого числа 5. Ці операції повторюються
                для тої частини послідовності, що залишилася, до поки не будуть отримані усі прості
                числа у вказаному діапазоні.
            </p>
            <p>
                Описана ідея алгоритму Решета Ератосфену ілюстрована поданою нижче
                таблицею. У таблиці наведені усі натуральні числа від 2 до 100. Червоним помічені ті,
                які були видалені в процесі виконання алгоритму Решето Ератосфену
            </p>
            <img src="./photo/1_4.png" alt="">
            <p>
                Тепер розглянемо алгоритм детальніше та його програмну реалізацію task2_3.<br>
                <b>Для пошуку простих чисел методом Решета Ератосфену потрібно:</b><br>
                    1. Організувати масив натуральних чисел від 2 до n=100, а також логічний
                    масив table розмірністю n.<br>
                    2. У змінну i записати число 2, що є першим простим числом.<br>
                    3. З масиву натуральних чисел викреслити усі числа, кратні i, починаючи з 2*i.<br>
                    4. Записати в змінну i наступне за i число, що не викреслене.<br>
                    5. Повторювати дії, описані в двох попередніх кроках, до поки не вичерпаний
                    діапазон натуральних чисел.
            </p>
            <img src="./photo/1_5.png" alt="">
            <span id="t2"></span>
            <img src="./photo/1_6.png" alt="">
      </section>

        <section id=''>
            <h1>2. Оператор foreach</h1>
            <p>
                Оператор <b>foreach</b> використовується для перебору елементів в масивах та інших
                колекціях і є новим типом циклу, що реалізований в C#. Розглянемо приклад створення
                ступінчастого масиву, який заповнюється даними. За допомогою вкладених
                операторів циклу елементи масиву виводяться на консоль у вигляді матриці.<img src="./photo/2_1.png" alt="">
            </p>
            <span id="t3"></span>
      <br>
      <br>
      <br>
        </section >

    <section id=''>
        <h1>3. Генерація випадкових чисел</h1>
        <p>
            Потреба в генерації випадкових чисел часто виникає в програмуванні. В C# є
            нестатичний клас <b>Random</b>, методи якого дозволяють генерувати різні послідовності
            випадкових чисел. Нижче наведено приклад task2_5, в якому в методі <b>ValsGenerator()</b>
            створюється об'єкт <b>aRand</b>. Далі в циклі викликається метод <b>aRand.Next(100)</b>, який при
            кожному виклику генерує одне випадкове число від 1 до 100 і присвоює його черговому
            елементу масиву. Зверніть увагу, що метод <b>ValsGenerator()</b> є статичним.
        </p>
        <p>
            В методі <b>Main()</b> створюється масив <b>Data</b>, викликається метод <b>ValsGenerator()</b>
            для його заповнення, потім викликається метод <span style="color: rgb(6, 169, 169);">Array</span><b>.Sort(Data)</b> для його сортування.
            Після чого елементи масиву виводяться в циклі на консоль.
        </p>
        <img src="./photo/3_1.png" alt="">
        <img src="./photo/3_2.png" alt="">

        <p>Виведення масиву можнка записати з ідентифікацією елемента, значення якого виводиться на консоль, наприклад, </p>
        <img src="./photo/3_3.png" alt=""><span id="t4"></span>
        <p>Зверніть увагу, що при виведенні масиву виконується неявне приведення з типу
            <b>int</b> до типу <b>string</b></p>
    </section >

        <section id=''>
            <h1>4. Робота з математичними функціями класу Math</h1>
          <p>Для виконання різних математичних операцій у бібліотеці класів .NET
            призначено клас Math. Він є статичним, тому всі його методи також статичні.
            Розглянемо приклад task2_6 використання математичних функцій в задачах
            обчислювальної математики. Постановка задачі вимагає визначити дійсні корені
            рівняння 6x4 − 3x3 + 8x2 − 5 = 0 за методом бісекції (ділення навпіл) на відрізках [0, 1],
            [-1, 0].
          </p>
          <h1>Алгоритм методу</h1>
          <p>
            Нехай [а, b] відрізок, на якому шукають корені. Припустимо, що функція f(x)
            неперервна на [а, b] і на кінцях приймає значення різних знаків f (a) × f (b) < 0 .
          </p>
          <p>Алгоритм методу полягає в побудові послідовності вкладених відрізків, на кінцях яких
            функція приймає значення різних знаків. Кожний наступний відрізок отримують
            діленням навпіл попереднього. Опишемо один крок ітераційного методу. Нехай на
            k-му кроці знайдено відрізок такий, що <img src="./photo/4_2.png" alt="" class="form">. Знайдемо середину
            <img src="./photo/4_3.png" alt="" class="form">відрізку. Якщо <img src="./photo/4_4.png" alt="" class="form">
            - корінь і задача розв’язана. Якщо ні, то з двох половин відрізку вибираємо той, на кінцях якого функція має протилежні знаки:
          </p>
          <img src="./photo/4_5.png" alt="">
          <p>Критерій закінчення ітераційного процесу: якщо довжина відрізку знаходження
            кореня менше 2<sup>e</sup> , то ітерації припиняють і за значення кореня із заданою точністю
            приймають середину відрізку.<br>
            Код програми task2_6 може бути таким
          </p>
          <img src="./photo/4_6.png" alt="">
          <img src="./photo/4_7.png" alt="">
          <p>
            В цій програмі є метод <span style="color:rgb(4, 154, 154)">static double </span><b>f</b>(<span style="color:rgb(4, 154, 154)">double</span><b>x</b>), в якому визначається рівняння.
            Для обчислення степеню числа в методі <b>f()</b> використовується метод <span style="color:rgb(4, 154, 154)">Math</span><b>.Pow( )</b> класу
            <span style="color:rgb(4, 154, 154)">Math</span>.
          </p>
          <p>
            Другий метод <span style="color:rgb(4, 154, 154)">static double</span> <b>bicect</b>(<span style="color:rgb(4, 154, 154)">double</span> <b>left</b>, <span style="color:rgb(4, 154, 154)">double</span> <b>right</b>) реалізує ітераційний
            процес пошуку кореня рівняння методом бісекції. В методі <b>Main()</b> два рази
            викликається метод бісекцій для знаходження коренів на вказаних відрізках.
            Результати визначених коренів виводяться на консоль.
          </p>
          <p><span id="t5"></span>
            Для перевірки достовірності результатів розрахунку коренів використовується
            метод <span style="color:rgb(4, 154, 154)">static void</span> <b>verify</b>(<span style="color:rgb(4, 154, 154)">double</span> <b>root</b>, <span style="color:rgb(4, 154, 154)">double</span> <b>precision</b>), в якому в ліву частину заданого
            рівняння підставляються значення знайдених коренів. Результат підстановки
            порівнюється із значенням, яке обчислюється в методі <b>f()</b> із вказаною точністю
            перевірки.
          </p>
        </section >

            <section id=''>
            <h1> 5. Лінійний пошук в масиві</h1>
             <p>Лінійний або послідовний пошук реалізує алгоритм знаходження заданого
              значення довільної функції на деякому відрізку.
              Формальний запис алгоритму</p>
             <p>1. Визначити ключ пошуку key, значення якого потрібно знайти в масиві.</p>
             <p>2. Встановити границі L (left), R (right) області пошуку для масиву mas;</p>
             <p>3. Якщо значення і-го елемента масиву mаsi дорівнює ключу пошуку key, елемент
              знайдений.</p>
             <p>4. Інакше – перейти до наступного елементу масиву і повторити дії пп.3 та 4.</p>  
             <img src="./photo/5_1.png" alt="">
             <img src="./photo/5_2.png" alt="">
             
             <img src="./photo/5_3.png" alt="">

             <span id="t6"></span>
      <br>
      <br>
      <br>
            </section >


    <section class="last" id=''>
        <h1>6. Двійковий (бінарний) пошук</h1>
        <p>
          Двійковий (бінарний) пошук (також відомий як метод ділення навпіл або
          дихотомія) є класичним алгоритмом пошуку елемента у відсортованому масиві.
          Формальний запис алгоритму.<br>
          1. Масив ділиться на дві рівні частини, шляхом визначення першого (a),
          останнього (b) і середнього (c) елементів.<br>
            <i>2. Середній елемент порівнюється з шуканим (s).</i><br>
          2.1. Якщо s < c, останньому елементу b присвоюється значення середнього
          b = c, тим самим ділянка пошуку зменшується удвічі.<br>
          2.2. Якщо s > c, першому елементу a приcвоюється значення середнього
          a = с, і ділянка пошуку зменшується удвічі.<br>
          2.3. Якщо s = c, елемент знайдений, і робота алгоритму завершується.<br>
          3. Якщо для перевірки не залишилося жодного елементу, алгоритм
          завершується, інакше виконується перехід до пункту 2.  
        </p>
        <img src="./photo/6_1.png" alt="">
        <img src="./photo/6_2.png" alt="">
        <img src="./photo/6_3.png" alt="">
        <img src="./photo/6_4.png" alt="">
        
      <div class="up">
        <a class= "class_up" href="#">UP</a>
      </div>
    </section>

    
</div>

<div id="page">
  <footer>
    <div class="wave">
  <svg width="516px" height="63px" viewBox="0 -1 516 63" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
      <desc>Created with Sketch.</desc>
      <defs></defs>
      <path d="M465.8994,4.8023 C446.8704,0.1653 446.8544,10.3203 432.2774,10.9823 C412.6824,11.8733 403.5104,-0.1977 386.8714,0.0033 C370.2314,-0.1977 357.0194,8.6003 357.0194,8.6003 L357.0194,8.6053 C351.2924,11.3603 345.9174,13.6933 338.4874,13.6933 C322.4554,13.6933 322.9524,8.0883 311.5974,6.3063 C300.6744,4.5933 297.4354,11.2593 286.3754,11.2593 C275.3164,11.2593 268.4204,2.9423 257.9144,2.9423 C247.4084,2.9423 227.1374,9.4693 207.9854,4.8023 C188.9564,0.1653 188.9404,10.3203 174.3634,10.9823 C154.7694,11.8733 145.5964,-0.1977 128.9574,0.0033 C112.3174,-0.1977 99.1054,8.6003 99.1054,8.6003 L99.1054,8.6053 C93.3774,11.3603 88.0034,13.6933 80.5734,13.6933 C64.5414,13.6933 65.0384,8.0883 53.6834,6.3063 C42.7604,4.5933 39.5214,11.2593 28.4614,11.2593 C17.4024,11.2593 10.5054,2.9423 0.0004,2.9423 L0.0004,61.9433 L515.8284,61.9433 L515.8284,2.9423 C505.3224,2.9423 485.0514,9.4693 465.8994,4.8023" id="Fill-1" stroke="none" fill="#E4BDB5" fill-rule="evenodd"></path>
  </svg>
  <p class="robot">©2024 Furkalo Daniil</p>
    </div>
  </footer>

  </div>


</body>
</div>
</body>
</html>