<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="../../style.css">
    <link rel="stylesheet" href="../../style_test.css">
    <link rel="icon" href="../../Rating/photo/logo_4.png" type="image/png">
    <title>Я в тебе вірю!</title>
</head>
<body>
    <!-- Overlay for fixed sidebar -->
<div class="sidebar-overlay"></div>

<header>
    <h1>Навчайся через практику! C#</h1>
    <nav>
      <a href="../Theory/Lab_5_theory.html">Теоретичні відомості</a>
      <a href="../Text/Lab_5_text.html">Текст програми та Виконання прикладу</a>
      <a href="../example/Lab_5_example.html">Варіанти завдань</a>
      <a href="../Test/Lab_5_test.html">Контрольні запитання та література</a>
    </nav>
  </header>

<!-- navbar  -->
<div class="navbar">

  <input type="checkbox" class="checkbox" id="click" hidden>

  <!-- sidebar -->
  <div class="sidebar">
      <label for="click">
          <div class="menu-icon">
              <div class="line line-1"></div>
              <div class="line line-2"></div>
              <div class="line line-3"></div>
          </div>
          <p class="sidebar-text">Лаб 5</p>
      </label>
  </div>
  <!-- end of sidebar -->

<!--navigation-->
<nav class="navigation">
  <div class="navigation-header">
    <h1 class="navigation-heading">Робота</h1>
    
  </div>
  
  <ul class="navigation-list">
    <li class="navigation-item">
      <a href="../../Lab_1/Theory/Lab_1.html" class="navigation-link">Лабораторна робота №1</a>
    </li>
    <li class="navigation-item">
      <a href="../../Lab_2/Theory/Lab_2_theory.html" class="navigation-link">Лабораторна робота №2</a>
    </li>
    <li class="navigation-item">
      <a href="../../Lab_3/Theory/Lab_3_theory.html" class="navigation-link">Лабораторна робота №3</a>
    </li>
    <li class="navigation-item">
      <a href="../../Lab_4/Theory/Lab_4_theory.html" class="navigation-link">Лабораторна робота №4</a>
    </li>
    <li class="navigation-item">
      <a href="../../Lab_5/Theory/Lab_5_theory.html" class="navigation-link">Лабораторна робота №5</a>
    </li>
    <li class="navigation-item">
      <a href="../../Lab_6/Theory/Lab_6_theory.html" class="navigation-link">Лабораторна робота №6</a>
    </li>
    <li class="navigation-item">
      <a href="https://docs.google.com/document/d/1ptKIyE0X2zUnQkgTMD9tHxrOsJyIKWYG3R9astTJBKA/edit" target="_blank" class="navigation-link">Теми індивідуальних творчих робіт</a>
    </li>
    <li class="navigation-item">
      <a href="../../Rating/index.html" class="navigation-link">Рейтингова система</a>
    </li>
  </ul>
</nav>
</div>
<!-- end of navbar  -->      


  <div class="wrapper">
      <section id='steezy'>
        <div class="up">
          <a class= "class_up" href="#">UP</a>
        </div>
        <h1>Приклади виконання завдань</h1>
        <div class="my-my-list">
            <a class ="a-list" href="#t1">Приклад 1</a><br>
            <a class ="a-list" href="#t2">Приклад 2</a><br>
            <a class ="a-list" href="#t3">Приклад 3</a><br>
            <a class ="a-list" href="#t4">Приклад 4</a><br>
            <a class ="a-list" href="#t5">Приклад 5</a><br>
            <a class ="a-list" href="#t6">Приклад 6</a><br>
            <a class ="a-list" href="#t7">Приклад 7</a><br>
          </div>
            <br>
        <p>
            Поліморфізм є третім принципом об'єктно-орієнтованого програмування після
            інкапсуляції та успадкування. Поліморфізм означає "різноманітність форм".
            Поліморфізм – це властивість програмного коду змінювати свою поведінку в
            залежності від ситуації, яка виникає при виконанні програми. В контексті реалізації
            поліморфізм – це технологія виклику віртуальних функцій, що реалізовані в ієрархічно
            зв’язаних класах. Ієрархія класів формується на основі механізму спадковості. Під час
            виконання об’єкти похідного класу можуть бути оброблені як об’єкти базового класу,
            якщо вони є параметрами методу, колекціями або масивами. Коли виникає
            поліморфізм, оголошений тип об’єкта перестає відповідати своєму типу під час
            виконання.<br><span id="t1"></span>
            Базові класи можуть визначати та реалізовувати віртуальні методи, а похідні
            класи − перевизначати їх, тобто надавати своє власне визначення та реалізацію. У
            вихідному коді можна викликати метод у базовому класі та забезпечити виконання
            версії методу, що відноситься до похідного класу.
        </p>

        <h1>1. Перевантаження методів</h1>
        <p>
            Використання декількох методів з одним і тим самим <b>іменем</b>, але різними
            типами <b>параметрів</b> називається <b>перевантаженням методів</b>.<br>
            Компілятор визначає, який саме метод потрібно викликати за типом
            фактичних параметрів. Наприклад, нижче наведено декілька оголошень метода
            <b>max()</b>, який повертає найбільше із значень для різних типів і кількості
            параметрів. Студентам пропонується написати реалізації оголошених методів
            самостійно.
        </p>
        <img src="./photo/1_1.png" alt="">
        <p>
            Багато методів, які реалізовані в мові C#, перевантажені.
        </p>
        <span id="t2"></span>
      <br>
      <br>
      <br>
      </section>


    <section id='t2'>
        <h1>2. Віртуальні члени класу</h1>
        <p>
            Базові класи можуть визначати і реалізовувати <b>віртуальні методи</b>, а похідні
            класи − перевизначати їх, тобто надавати своє власне визначення і реалізацію. Під час
            виконання, коли клієнт викликає метод, CLR виконує пошук типу об'єкта під час
            виконання і викликає перезапис віртуального методу. У вихідному коді можна
            викликати метод в базовому класі і забезпечити виконання версії методу, що
            відноситься до похідному класу.<br>
            Похідний член повинен використовувати ключове слово <b>override</b>, яке вказує, що
            метод призначений для участі у віртуальному виклику. Віртуальні методи і властивості
            дозволяють похідним класам розширювати базовий клас без необхідності
            використовувати реалізацію методу базового класу.</p>
            <img src="./photo/2_1.png" alt="">
            <img src="./photo/2_2.png" alt="">
    </section >

        <section id='t3'>
          <span id="t3"></span>
      <br>
      <br>
      <br>
            <h1>3. Приховування членів базового класу новими членами</h1>
            <p>
                Якщо ви хочете, щоб похідний клас мав член з тим самим іменем, що і член в
                базовому класі, можна використовувати ключове слово <b>new</b>, щоб приховати член
                базового класу. Ключове слово new вставляється перед типом значення, що
                повертається, члена класу, що заміщає. Розглянемо приклад <b>task5_3</b>.
            </p>
            <img src="./photo/3_1.png" alt="">
            <img src="./photo/3_2.png" alt="">
            <p>
                Тут визначено клас Person, який представляє людину, та клас <b>Employee</b>, який
                представляє працівника підприємства. Клас <b>Employee</b> успадковує від класу <b>Person</b> всі
                властивості та методи. Але в класі <b>Employee</b>, крім успадкованих властивостей, є також
                і власна властивість <b>Company</b>, яка зберігає назву компанії. І потрібно в методі <b>Print()</b>
                виводити інформацію про компанію разом із ім’ям працівника на консоль. Для цього
                визначається метод <b>Print()</b> з ключовим словом new, який приховує реалізацію методу
                з базового класу.<br>
                В яких ситуаціях можна використовувати приховування? Наприклад, у
                поданому вище прикладі метод <b>Print()</b> у базовому класі не є віртуальним, ми не
                можемо його перевизначити, але, припустимо, нас не влаштовує його реалізація для
                похідного класу, тому ми можемо скористатися прихованням, щоб визначити
                потрібний нам функціонал у похідному класі.</p>
                <span id="t4"></span>
      <br>
      <br>
      <br>
        </section >

            <section id='t4'>
              
                <h1>4. Захист віртуальних членів від перевизначення похідними класами</h1>
                <p>
                    Похідний клас може зупинити віртуальне успадкування, оголосивши
                    перевизначення як <b>запечатаний</b>. Для зупинки спадкування в C# в оголошення класу
                    або члена класу потрібно вставити ключове слово <b>sealed</b>. Отже, ключове слово <b>sealed</b>
                    використовується у двох випадках: коли потрібно заборонити спадкування від певного
                    класу; коли необхідно заборонити перевизначення деякого методу або властивості в
                    ієрархії класів. Ця ситуація можлива, якщо в ієрархії класів методи успадкованих
                    класів перевизначають віртуальні методи базових класів. Це дозволяє класам
                    успадковувати від іншого класу, забороняючи їм перевизначати певні віртуальні
                    методи або властивості. При створенні методів з модифікатором <b>sealed</b> треба
                    враховувати, що <b>sealed</b> застосовується в парі з <b>override</b>, тобто тільки в методах, що
                    перевизначаються.
                </p>
                <img src="./photo/4_1.png" alt="">
                <p>
                    Розглянемо приклад <b>task5_4</b>, в якому описані класи <b>Person</b>, <b>Employee</b>, похідний
                    від <b>Person</b>, та <b>Developer</b>, похідний від <b>Employee</b>. В класі <b>Person</b> визначимо
                    віртуальний метод <b>Print()</b>, який перевизначимо та запечатаємо в класі <b>Employee</b>. В
                    класі <b>Developer</b> спробуємо перевизначити запечатаний в базовому класі метод <b>Print()</b>.
                    Отримаємо помилку компіляції: неможливо перевизначити член <b>Employee.Print()</b>, що
                    успадковується, оскільки він запечатаний. І в цьому випадку ми не зможемо
                    перевизначити метод <b>Print()</b> у класі, успадкованому від <b>Employee</b>.
                    Прикладом використання модифікатора sealed є наступний код програми
                    <b>task5_4</b>:
                </p>
                <img src="./photo/4_2.png" alt="">
                <img src="./photo/4_3.png" alt="">
                <span id="t5"></span>
                <br>
                <br>
                <br>
            </section >

                <section id='t5'>
                    <h1>5. Доступ до віртуальних членів базового класу з похідних класів</h1>
                    <p>
                        Похідний клас, який замінив або перевизначив метод або властивість, може
                        отримати доступ до методу або властивості базового класу за допомогою ключового
                        слова <b>base</b>.
                    </p>
                    <img src="./photo/5_1.png" alt="">
                    <span id="t6"></span>
      <br>
      <br>
      <br>
                </section >

                    <section id='t6'>

                        <h1>6. Перевантаження операторів</h1>
                        <p>
                            Поряд з методами можна перевантажувати оператори. Для перевантаження
                            оператора служить ключове слово <b>operator</b>, що визначає операційний метод, який, в
                            свою чергу, визначає дію оператора щодо свого класу. Існують дві форми операторних
                            методів (operator): одна − для унарних операторів, інша − для бінарних. Нижче наведена
                            загальна форма для кожного різновиду цих методів:
                        </p>
                        <img src="./photo/6_1.png" alt="">

                        <h1>6.1. Перевантаження бінарних операторів</h1>
                        <p>
                            Для бінарних операторів (+, -, *, /, %, ==, !=, >, < тощо) тип значення, що
                            повертається, співпадає з класом, в якому перевантажується оператор. В якості
                            параметрів використовуються об’єкти того самого класу, що й тип значення, що
                            повертається. Зверніть увагу на те, що операційні методи повинні мати обидва
                            специфікатори типу <b>public</b> і <b>static</b>, оскільки застосовуються до усіх об’єктів
                            (екземплярів) класу. Розглянемо приклад task5_5
                        </p>
                        <img src="./photo/6_2.png" alt="">
                        <img src="./photo/6_3.png" alt="">

                        <h1>6.2. Перевантаження унарних операторів</h1>
                        <p>
                        Унарні оператори (++, --, -) перевантажуються так само як і бінарні. Головна
                        відмінність полягає в тому, що методи мають лише один операнд. Для унарних
                        операторів параметр позначає операнд, що передається.
                        </p>
                        <img src="./photo/6_4.png" alt="">
                        <img src="./photo/6_5.png" alt="">
                        <span id="t7"></span>
      <br>
      <br>
      <br>
                    </section >

    <section class="last">  
        <h1>7. Індексатори</h1>
        <p>
            Індексатори дозволяють індексувати об'єкти і звертатися до даних за індексом.
            Фактично за допомогою індексаторів ми можемо працювати з об'єктами як з масивами.
            За формою вони нагадують властивості зі стандартними блоками <b>get</b> і <b>set</b>, які
            повертають і привласнюють значення. Формальне визначення індексатора:
        </p>
        <img src="./photo/7_1.png" alt="">
        <p>
            На відміну від властивостей індексатор не має назви. Замість нього вказується
            ключове слово <b>this</b>, після якого в квадратних дужках йдуть параметри. Індексатор
            повинен мати як мінімум <b>один параметр</b>.
        </p>
        <img src="./photo/7_2.png" alt="">
        <img src="./photo/7_3.png" alt="">
        <p>
            Слід враховувати, що індексатор <b>не може бути статичним</b> і застосовується
            тільки до примірника класу. Але при цьому індексатори можуть бути <b>віртуальними</b> й
            <b>абстрактними</b> і можуть перевизначатися в похідних класах.
        </p>
    </section>

    
</div>

<div id="page">
  <footer>
    <div class="wave">
  <svg width="516px" height="63px" viewBox="0 -1 516 63" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
      <desc>Created with Sketch.</desc>
      <defs></defs>
      <path d="M465.8994,4.8023 C446.8704,0.1653 446.8544,10.3203 432.2774,10.9823 C412.6824,11.8733 403.5104,-0.1977 386.8714,0.0033 C370.2314,-0.1977 357.0194,8.6003 357.0194,8.6003 L357.0194,8.6053 C351.2924,11.3603 345.9174,13.6933 338.4874,13.6933 C322.4554,13.6933 322.9524,8.0883 311.5974,6.3063 C300.6744,4.5933 297.4354,11.2593 286.3754,11.2593 C275.3164,11.2593 268.4204,2.9423 257.9144,2.9423 C247.4084,2.9423 227.1374,9.4693 207.9854,4.8023 C188.9564,0.1653 188.9404,10.3203 174.3634,10.9823 C154.7694,11.8733 145.5964,-0.1977 128.9574,0.0033 C112.3174,-0.1977 99.1054,8.6003 99.1054,8.6003 L99.1054,8.6053 C93.3774,11.3603 88.0034,13.6933 80.5734,13.6933 C64.5414,13.6933 65.0384,8.0883 53.6834,6.3063 C42.7604,4.5933 39.5214,11.2593 28.4614,11.2593 C17.4024,11.2593 10.5054,2.9423 0.0004,2.9423 L0.0004,61.9433 L515.8284,61.9433 L515.8284,2.9423 C505.3224,2.9423 485.0514,9.4693 465.8994,4.8023" id="Fill-1" stroke="none" fill="#E4BDB5" fill-rule="evenodd"></path>
  </svg>
  <p class="robot">©2024 Furkalo Daniil</p>
    </div>
  </footer>
  </div>


</body>
</div>
</body>
</html>