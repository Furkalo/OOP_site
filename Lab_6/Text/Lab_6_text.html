<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="../../style.css">
    <link rel="stylesheet" href="../../style_test.css">
    <link rel="icon" href="../../Rating/photo/logo_4.png" type="image/png">
    <title>Остання))))))</title>
</head>
<body>
    <!-- Overlay for fixed sidebar -->
<div class="sidebar-overlay"></div>

<header>
    <h1>Навчайся через практику! C#</h1>
    <nav>
      <a href="../Theory/Lab_6_theory.html">Теоретичні відомості</a>
      <a href="../Text/Lab_6_text.html">Текст програми та Виконання прикладу</a>
      <a href="../example/Lab_6_example.html">Варіанти завдань</a>
      <a href="../Test/Lab_6_test.html">Контрольні запитання та література</a>
    </nav>
  </header>

<!-- navbar  -->
<div class="navbar">

  <input type="checkbox" class="checkbox" id="click" hidden>

  <!-- sidebar -->
  <div class="sidebar">
      <label for="click">
          <div class="menu-icon">
              <div class="line line-1"></div>
              <div class="line line-2"></div>
              <div class="line line-3"></div>
          </div>
          <p class="sidebar-text">Лаб 6</p>
      </label>
  </div>
  <!-- end of sidebar -->

<!--navigation-->
<nav class="navigation">
  <div class="navigation-header">
    <h1 class="navigation-heading">Робота</h1>
    
  </div>
  
  <ul class="navigation-list">
    <li class="navigation-item">
      <a href="../../Lab_1/Theory/Lab_1.html" class="navigation-link">Лабораторна робота №1</a>
    </li>
    <li class="navigation-item">
      <a href="../../Lab_2/Theory/Lab_2_theory.html" class="navigation-link">Лабораторна робота №2</a>
    </li>
    <li class="navigation-item">
      <a href="../../Lab_3/Theory/Lab_3_theory.html" class="navigation-link">Лабораторна робота №3</a>
    </li>
    <li class="navigation-item">
      <a href="../../Lab_4/Theory/Lab_4_theory.html" class="navigation-link">Лабораторна робота №4</a>
    </li>
    <li class="navigation-item">
      <a href="../../Lab_5/Theory/Lab_5_theory.html" class="navigation-link">Лабораторна робота №5</a>
    </li>
    <li class="navigation-item">
      <a href="../../Lab_6/Theory/Lab_6_theory.html" class="navigation-link">Лабораторна робота №6</a>
    </li>
    <li class="navigation-item">
      <a href="https://docs.google.com/document/d/1-M0utDukFfgVVEO6VYmcW5pli5XF0tA3/edit" target="_blank" class="navigation-link">Теми індивідуальних творчих робіт</a>
    </li>
    <li class="navigation-item">
      <a href="../../Rating/index.html" class="navigation-link">Рейтингова система</a>
    </li>
  </ul>
</nav>
</div>
<!-- end of navbar  -->      


  <div class="wrapper">
      <section id='steezy'>
        <div class="up">
          <a class= "class_up" href="#">UP</a>
        </div>

        <h1>Приклади виконання завдань</h1>
        <div class="my-my-list">
            <a class ="a-list" href="#t1">Приклад 1</a><br>
            <a class ="a-list" href="#t2">Приклад 2</a><br>
            <a class ="a-list" href="#t3">Приклад 3</a><br>
          </div>
            <br>
        <b>1. Програма обробки виключних ситуацій</b>
        <p>
            При створенні програм із застосуванням структурованої обробки виключень
            передбачається використовувати такі чотири взаємозалежних елементи:<br>
            • тип класу, який надає детальну інформацію про виниклу виняткову ситуацію;<br>
            • член, який генерує, або надсилає (<b>throw</b>) екземпляр класу, що відповідає
            винятковій ситуації, стороні, що викликає;<br>
            • блок програмного коду, в якому був викликаний член, що генерує виняток;<br>
            • блок програмного коду сторони, що викликає, в якому виконується обробка,
            або захоплення (<b>catch</b>) даного виключення.<br>
            У мові програмування C# пропонуються чотири ключових слова (<b>try, catch,
            throw і finally</b>), за допомогою яких генеруються і обробляються виключення. Тип, що
            представляє відповідну проблему, є класом, похідним від <b>System.Exception</b> (або його
            нащадком).<br>
            З урахуванням цього давайте з'ясуємо роль зазначеного базового класу.
            Створимо новий консольний додаток <b>task6_1</b>, в якому визначатимуться два класи <b>Car</b>
            (автомобіль) і <b>Radio</b> (радіо), пов'язані відношенням агрегації ("has-a"). Тип <b>Radio</b>
            визначає один метод, що включає і вимикає радіо.
        </p>
        <img src="./photo/1_1.png" alt="">
        <img src="./photo/1_2.png" alt="">
        <p>
            Клас Car (автомобіль) визначає таку поведінку. Якщо користувач об'єкта <b>Car</b>
            перевищить межу для швидкості (ця межа задається значенням члена-константи),
            «двигун вибухає» і об'єкт <b>Car</b> стає непридатним для використання, що виражається
            змінами значення поля типу bool з ім'ям <b>carIsDead</b> (автомобіль зруйнований). Крім
            того, тип <b>Car</b> має кілька членів-змінних, що представляють поточну швидкість і ім'я,
            дане автомобілю користувачем, а також кілька конструкторів. Ось повне визначення
            цього типу (з відповідними коментарями).
        </p>
        <img src="./photo/1_3.png" alt="">
        <img src="./photo/1_4.png" alt="">
        <p>
            Припустимо, що ми хочемо створити для користувача виняток (з ім'ям
            <b>CarException</b>), що представляє помилку перевищення швидкості приреченого
            автомобіля. Насамперед тут має бути створення нового класу з
            <b>System.ApplicationException</b> (за згодою, класи виключень мають суфікс "Exception",
            що в перекладі означає "виключення"). Як і в разі будь-якого іншого класу, можна
            визначити для користувача члени, які будуть потім використовуватися в блоці catch в
            рамках програмної логіки викликів. Точно так само можна перевизначити будь-які
            віртуальні члени, визначені батьківськими класами. Наприклад, можна реалізувати
            <b>CarException</b>, перевизначивши віртуальну властивість <b>Messagе</b>.<br>
            Якщо ви хочете побудувати точний призначений для користувача клас
            виключення, то створений вами тип повинен відповідати кращим зразкам, які
            використовують виключення .NET. Зокрема, ваше призначене для користувача
            виняток мав би підпорядковуватися наступним вимогам:<br>
            • бути похідним від <b>Exception</b> / <b>ApplicationException</b>;<br>
            • визначати конструктор, який використовується за умовчанням;<br>
            • визначати конструктор, який встановлює успадковане властивість Message;<br>
            • визначати конструктор, що обробляє "внутрішні виключення".
        </p>
        <img src="./photo/1_5.png" alt="">
        <img src="./photo/1_6.png" alt="">
        <p>
            Метод <b>Accelerate()</b> може генерувати виключення, яке сторона, що викликає,
            повинна бути готова обробити такий виняток. При виклику методу, здатного
            генерувати виняток, ви повинні використовувати блок <b>try / catch</b>. Прийнявши виняток,
            ви можете викликати члени типу <b>System.Exception</b> і прочитати детальну інформацію
            про проблему. Що ви будете робити з отриманими даними, залежить, в основному, від
            вас. Ви можете помістити відповідну інформацію в файл звіту, записати її в журнал
            реєстрації подій <b>Windows</b>, відправити її електронною поштою адміністратору системи
            або показати повідомлення з описом проблеми кінцевому користувачеві. Тут ми просто
            виводимо інформацію у вікно консолі.<br>
            В рамках блоку <b>try / catch</b> можна також визначити необов'язковий блок <b>finally</b>.
            Завдання блоку <b>finally</b> – забезпечити безумовне виконання деякого набору операторів
            програмного коду, незалежно від наявності або відсутності виключення (будь-якого
            типу). Для прикладу припустимо, що ви хочете завжди вимикати радіо автомобіля
            перед виходом з <b>Main()</b>, незалежно від винятків.
        </p>
        <img src="./photo/1_7.png" alt="">
        <img src="./photo/1_8.png" alt="">
        <span id="t2"></span>
      <br>
      <br>
      <br>
      </section>

    <section>
        <h1>2. Поняття делегатів та їх використання</h1>
        <p>
            Делегат – це тип, який представляє посилання на методи з певним списком
            параметрів і типом значення, що повертається, тобто делегат описує сигнатуру методу.
            При створенні екземпляра делегата цей екземпляр можна пов'язати з будь-яким
            методом з сумісною сигнатурою і типом значення, що повертається. Метод можна
            викликати (активувати) за допомогою екземпляра делегата.<br>
            Делегати використовуються для передачі методів в якості аргументів до інших
            методів. Обробники подій – це ніщо інше, як методи, що викликаються за допомогою
            делегатів. При створенні користувальницького методу клас (наприклад, елемент
            керування Windows) може викликати цей метод при появі певної події.<br>
            У наступному прикладі показано оголошення делегата:<br><br>

            <span style="color:rgb(77, 77, 225)">public delegate тип_значення_що_повертається ім’я_делегата(список параметрів);</span>
            <br><br>
            Делегату можна призначити будь-який метод з будь-якого доступного класу або
            структури, що відповідає типу делегата. Цей метод повинен бути <b>статичним методом</b>
            або методом екземпляра. Така гнучкість дозволяє програмно змінювати виклики
            методу, а також включати новий код в існуючі класи.</p>

        <h1>Властивості делегата</h1>
        <p>
            1. Делегати подібні покажчикам на функції в C++, але є повністю об'єктноорієнтованими і, на відміну 
            від покажчиків C++ на функції-члени,
            інкапсулюють екземпляр об'єкта разом з методом.<br>
            2. Делегати допускають передачу методів в якості параметрів.<br>
            3. Делегати можна використовувати для визначення методів зворотного
            виклику.<br>
            4. Делегати можна пов'язувати між собою; наприклад, при появі одної події
            можна викликати кілька методів.<br>
            5. Точна відповідність методів типу делегата не потрібна.
        </p>    
            <h1>Приклад коду з використанням делегата</h1>
        <p>
            Розглянемо приклад <b>task6_2</b>, в якому необхідно змінити рядок символів,
            видаливши пробіли або замінивши пробіли на інший символ. Операції модифікації
            рядка символів подати методами, яким передається вхідний рядок для модифікації.
            Методи повертають рядок, що змінений відповідно до умови задачі. Для виклику
            методів використати делегат, який повертає тип <b>string</b>, і приймає в якості параметра
            рядок.
        </p>
        <img src="./photo/2_1.png" alt="">
          <p>
            Код головної функції, яка використовуватиме делегат, працює так:
            1. Створити об’єкт делегат відповідно до його оголошення. В якості параметра
            використати ім’я функції, яку викликатиме делегат. Використовуються
            складені імена:
            ім’я класу.ім’я делегата для об’єкта делегата
            ім’я класу.ім’я функції для параметра делегата
            2. Викликати об’єкт делегата, передавши йому в якості аргументу вхідний
            рядок
            3. Створити новий екземпляр делегата відповідно до його оголошення.
            4. Викликати об’єкт делегата, передавши йому в якості аргументу новий рядок
            5. Вивести на консоль результати виконання функцій, яким делегат передає
            управління.
          </p>
          <img src="./photo/2_2.png" alt="">
          <img src="./photo/2_3.png" alt="">
          <span id="t3"></span>
      <br>
      <br>
      <br>
    </section >

    <section class="last">  
      <h1>3. Використання подій і делегатів для їх підтримки</h1>
      <p>
        Подія являє собою автоматичне повідомлення про те, що відбулася деяка дія.
        Події діють за таким принципом: об'єкт, що виявляє інтерес до події, реєструє обробник
        цієї події. Коли ж подія відбувається, викликаються всі зареєстровані обробники цієї
        події. Обробники подій зазвичай представлені делегатами.<br>
        Події є членами класу і оголошуються за допомогою ключового слова event.
        Найчастіше для цієї мети використовується наступна форма:
        <br><br>
        <span style="color:rgb(77, 77, 225)">event делегат_події ім’я_події;</span>   
        <br><br>
        Як і делегати, події підтримують групову адресацію. Це дає можливість
        декільком об'єктам реагувати на повідомлення про подію.<br>
        Методи екземпляра і статичні методи можуть бути використані в якості
        обробників подій, але між ними є одна істотна відмінність. Коли статичний метод
        використовується в якості обробника, повідомлення про подію поширюється на весь
        клас. А коли в якості обробника використовується метод екземпляра, то події
        адресуються конкретним екземплярів об'єктів. Отже, кожен об'єкт певного класу,
        якому потрібно отримати повідомлення про подію, повинен бути зареєстрований
        окремо. На практиці більшість обробників подій є методами екземпляра.
    </p>
    <img src="./photo/3_1.png" alt="">
    <img src="./photo/3_2.png" alt="">
    <img src="./photo/3_3.png" alt="">
    </section>

    
</div>

<div id="page">
  <footer>
    <div class="wave">
  <svg width="516px" height="63px" viewBox="0 -1 516 63" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
      <desc>Created with Sketch.</desc>
      <defs></defs>
      <path d="M465.8994,4.8023 C446.8704,0.1653 446.8544,10.3203 432.2774,10.9823 C412.6824,11.8733 403.5104,-0.1977 386.8714,0.0033 C370.2314,-0.1977 357.0194,8.6003 357.0194,8.6003 L357.0194,8.6053 C351.2924,11.3603 345.9174,13.6933 338.4874,13.6933 C322.4554,13.6933 322.9524,8.0883 311.5974,6.3063 C300.6744,4.5933 297.4354,11.2593 286.3754,11.2593 C275.3164,11.2593 268.4204,2.9423 257.9144,2.9423 C247.4084,2.9423 227.1374,9.4693 207.9854,4.8023 C188.9564,0.1653 188.9404,10.3203 174.3634,10.9823 C154.7694,11.8733 145.5964,-0.1977 128.9574,0.0033 C112.3174,-0.1977 99.1054,8.6003 99.1054,8.6003 L99.1054,8.6053 C93.3774,11.3603 88.0034,13.6933 80.5734,13.6933 C64.5414,13.6933 65.0384,8.0883 53.6834,6.3063 C42.7604,4.5933 39.5214,11.2593 28.4614,11.2593 C17.4024,11.2593 10.5054,2.9423 0.0004,2.9423 L0.0004,61.9433 L515.8284,61.9433 L515.8284,2.9423 C505.3224,2.9423 485.0514,9.4693 465.8994,4.8023" id="Fill-1" stroke="none" fill="#E4BDB5" fill-rule="evenodd"></path>
  </svg>
  <p class="robot">©2024 Furkalo Daniil</p>
    </div>
  </footer>
  </div>


</body>
</div>
</body>
</html>
