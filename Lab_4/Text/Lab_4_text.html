<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="../../style.css">
    <link rel="stylesheet" href="../../style_test.css">
    <link rel="icon" href="../../Rating/photo/logo_2.png" type="image/png">
    <title>Найстрашніше позаду)</title>
</head>
<body>
    <!-- Overlay for fixed sidebar -->
<div class="sidebar-overlay"></div>

<header>
    <h1>Навчайся через практику! C#</h1>
    <nav>
      <a href="../Theory/Lab_4_theory.html">Теоретичні відомості</a>
      <a href="../Text/Lab_4_text.html">Текст програми та Виконання прикладу</a>
      <a href="../example/Lab_4_example.html">Варіанти завдань</a>
      <a href="../Test/Lab_4_test.html">Контрольні запитання та література</a>
    </nav>
  </header>

<!-- navbar  -->
<div class="navbar">

  <input type="checkbox" class="checkbox" id="click" hidden>

  <!-- sidebar -->
  <div class="sidebar">
      <label for="click">
          <div class="menu-icon">
              <div class="line line-1"></div>
              <div class="line line-2"></div>
              <div class="line line-3"></div>
          </div>
          <p class="sidebar-text">Лаб 4</p>
      </label>
  </div>
  <!-- end of sidebar -->

<!--navigation-->
<nav class="navigation">
  <div class="navigation-header">
    <h1 class="navigation-heading">Робота</h1>
    
  </div>
  
  <ul class="navigation-list">
    <li class="navigation-item">
      <a href="../../Lab_1/Theory/Lab_1.html" class="navigation-link">Лабораторна робота №1</a>
    </li>
    <li class="navigation-item">
      <a href="../../Lab_2/Theory/Lab_2_theory.html" class="navigation-link">Лабораторна робота №2</a>
    </li>
    <li class="navigation-item">
      <a href="../../Lab_3/Theory/Lab_3_theory.html" class="navigation-link">Лабораторна робота №3</a>
    </li>
    <li class="navigation-item">
      <a href="../Theory/Lab_4_theory.html" class="navigation-link">Лабораторна робота №4</a>
    </li>
    <li class="navigation-item">
      <a href="../../Lab_5/Theory/Lab_5_theory.html" class="navigation-link">Лабораторна робота №5</a>
    </li>
    <li class="navigation-item">
      <a href="../../Lab_6/Theory/Lab_6_theory.html" class="navigation-link">Лабораторна робота №6</a>
    </li>
    <li class="navigation-item">
      <a href="https://docs.google.com/document/d/1ptKIyE0X2zUnQkgTMD9tHxrOsJyIKWYG3R9astTJBKA/edit" target="_blank" class="navigation-link">Теми індивідуальних творчих робіт</a>
    </li>
    <li class="navigation-item">
      <a href="../../Rating/index.html" class="navigation-link">Рейтингова система</a>
    </li>
  </ul>
</nav>
</div>
<!-- end of navbar  -->      


  <div class="wrapper">
      <section id='steezy'>
        <div class="up">
          <a class= "class_up" href="#">UP</a>
        </div>
        <h1 style="font-size: 2.4rem;" >Приклади виконання завдань</h1>

        <div class="my-my-list">
          <a class ="a-list" href="#t1">Приклад 1</a><br>
          <a class ="a-list" href="#t2">Приклад 2</a><br>
          <a class ="a-list" href="#t3">Приклад 3</a><br>
          <a class ="a-list" href="#t4">Приклад 4</a><br>
          <a class ="a-list" href="#t5">Приклад 5</a><br>
          <a class ="a-list" href="#t6">Приклад 6</a><br>
          <a class ="a-list" href="#t7">Приклад 7</a><br>
          <a class ="a-list" href="#t8">Приклад 8</a><br>
        </div>
          <br>
          <br>
          <p>
            Спадкування — один з трьох фундаментальних принципів об'єктноорієнтованого програмування, 
            оскільки саме завдяки йому можливо створення
            ієрархічних класифікацій. Використовуючи спадкування, можна створити загальний
            клас, який визначає характеристики, властиві множини пов'язаних елементів. Цей клас
            потім може бути успадкований іншими, вузькоспеціалізованими класами з додаванням<span id="t1"></span>
            
            до кожного з них своїх унікальних особливостей. В мові С# клас, який успадковується,
            називається базовим або суперкласом. Клас, який успадковує базовий клас,
            називається похідним. Отже, похідний клас — це спеціалізована версія базового класу.<br>
            У похідний клас, що успадковує всі змінні, методи, властивості, оператори і
            індексатори, визначені в базовому класі, можуть бути додані унікальні елементи.
        </p>
        <h1>1. Оголошення базових і похідних класів</h1>
        <p>
            Розглянемо приклад <b>task4_1</b>. Нехай є клас <b>Person</b>, який описує людину,
            використовуючи її ім’я name. Для виведення на консоль значення імені означений
            метод <b>Display()</b>.
        </p>
        <img src="./photo/1_1.png" alt="">
        <p>
            Для опису співробітників компанії нам став потрібен клас, що описує
            співробітника підприємства, наприклад, клас <b>Employee</b>. Оскільки цей клас буде
            реалізовувати той самий функціонал, що і клас <b>Person</b>, так як співробітник – це також
            і людина, було б доцільним зробити клас <b>Employee</b> похідним (або спадкоємцем, або
            підкласом) від класу Person, який, в свою чергу, називається базовим класом або
            батьком (або суперкласом). Для класу <b>Employee</b> базовим є <b>Person</b>, і тому клас
            <b>Employee</b> успадковує всі ті самі властивості, методи, поля, які є в класі <b>Person</b>. Єдине,
            що не успадковується, тобто не передається при спадкуванні, це конструктори базового
            класу. Для успадкування базового класу необхідно після імені похідного класу через
            символ ':' вказати ім’я базового класу. 
        </p>
        <img src="./photo/1_2.png" alt="">
        <img src="./photo/1_3.png" alt="">
        <p>
            За замовчуванням усі класи успадковуються від базового класу <b>Object</b>, навіть
            якщо ми явно не встановлюємо успадкування. Тому вище означені класи Person і
            Employee крім своїх власних методів, також матимуть і методи класу <b>Object</b>:
            <b>ToString(), Equals(), GetHashCode() і GetType()</b>.<br>
            Існує ряд обмежень в процесі успадкування класів в C#:<br>
            • не підтримується множинне спадкування, клас може успадковуватися тільки
            від одного класу;<br>
            • при створенні похідного класу треба враховувати тип доступу до базового
            класу. Тип доступу до похідному класу повинен бути таким самим, як і у
            базового класу, або більш строгим. Тобто, якщо базовий клас має тип доступу
            <b>internal</b>, то похідний клас може мати тип доступу <b>internal</b> або <b>private</b>, але не
            <b>public</b>;<br>
            • якщо базовий і похідний класи знаходяться в різних збірках (проєктах), в
            цьому випадку похідний клас може успадковувати тільки від класу, який має
            модифікатор <b>public</b>;<br>
            • якщо клас оголошений з модифікатором <b>sealed</b>, то від цього класу не можна
            успадковувати і створювати похідні класи. 
        </p><span id="t2"></span>
        <br>
        <br>
        <br>
       </section>
          

    <section>
        <h1>2. Доступ до членів базового класу з класу-спадкоємця</h1>
        <p>
            Режим успадкування визначає спосіб успадкування елементів базового класу.
            Режим успадкування визначає, в які частини похідного класу потрапляють елементи
            базового класу. Похідний клас може мати доступ тільки до тих членів базового класу,
            які визначені з модифікаторами <b>private protected</b> (якщо базовий і похідний клас
            знаходяться в одній збірці), <b>public, internal</b> (якщо базовий і похідний клас знаходяться
            в одній збірці), <b>protected і protected internal</b>.</p>
            <img src="./photo/2_1.png" alt="">
            <span id="t3"></span>
      <br>
      <br>
      <br>
    </section >

        <section >
            <h1>3. Конструктори, ключове слово base</h1>
            <p>
                Тепер додамо в класи конструктори. Клас <b>Person</b> має конструктор, який
                встановлює властивість <b>Name</b>. Оскільки клас <b>Employee</b> успадковує і встановлює ту
                саму властивість <b>Name</b>, логічно було б не повторювати код установки, а викликати
                відповідний код класу <b>Person</b>. До того ж властивостей, які треба встановити в
                конструкторі базового класу, і параметрів може бути набагато більше. За допомогою
                ключового слова base можна звернутися до базового класу. У нашому випадку в
                конструкторі класу <b>Employee</b> треба встановити ім'я і компанію. Але ім'я ми передаємо
                на установку в конструктор базового класу, тобто в конструктор класу <b>Person</b>, за
                допомогою виразу <b>base</b> (name).
            </p>
            <img src="./photo/3_1.png" alt="">
            <p>Конструктори не передаються похідному класу при спадкуванні. І якщо в
                базовому класі не визначений конструктор за замовчуванням без параметрів, а тільки
                конструктори з параметрами (як у випадку з базовим класом <b>Person</b>), в похідному класі
                ми обов'язково повинні викликати один з цих конструкторів через ключове слово <b>base</b>. </p>
                <span id="t4"></span>
      <br>
      <br>
      <br>
        </section >

            <section>
            <h1>4. Порядок виклику конструкторів</h1>
            <p>
                При виклику конструктора похідного класу спочатку відпрацьовують
                конструктори базових класів і тільки потім конструктори похідних. Наприклад,
                візьмемо такі класи:
            </p>
            <img src="./photo/4_1.png" alt="">
            <p>
                У підсумку ми отримуємо наступний ланцюг виконань.<br>
                    Спочатку викликається конструктор <b>Employee</b> (string name, int age, string
                    company). <br>
                    Він делегує виконання конструктору <b>Person</b> (string name, int age).<br>
                    Викликається конструктор <b>Person</b> (string name, int age), який сам поки не
                    виконується і передає виконання конструктору <b>Person</b> (string name)<br>
                    Викликається конструктор <b>Person</b> (string name), який передає виконання
                    конструктору класу <b>System.Object</b>, так як це базовий за замовчуванням клас для
                    <b>Person</b>.<br>
                    Виконується конструктор <b>System.Object.Object()</b>, <br>
                    потім виконання
                    повертається конструктору <b>Person</b> (string name)<br>
                    Виконується тіло конструктора <b>Person</b> (string name), <br>
                    потім виконання
                    повертається конструктору <b>Person</b> (string name, int age)<br>
                    Виконується тіло конструктора <b>Person</b>(string name, int age), <br>
                    потім виконання
                    повертається конструктору <b>Employee</b> (string name, int age, string company)<br>
                    Виконується тіло конструктора <b>Employee</b> (string name, int age, string company).<br>
                    В результаті створюється об'єкт <b>Employee</b>.
            </p>
            <span id="t5"></span>
      <br>
      <br>
      <br>
            </section >

                <section id=''>
                    <h1>5. Інтерфейси</h1>
                    <p>
                        Інтерфейс являє посилальний тип, який може оголошувати деякий функціонал,
                        тобто набір методів і властивостей без їх реалізації. Потім цей функціонал реалізують
                        класи і структури, які застосовують дані інтерфейси.
                    </p>
                    
                    <h1>Оголошення інтерфейсу</h1>
                    <p>
                        Для оголошення інтерфейсу використовується ключове слово <b>interface</b>. Як
                        правило, назви інтерфейсів в C# починаються з великої літери I, наприклад,
                        <b>IComparable</b>, <b>IEnumerable</b> (так звана угорська нотація), однак це не обов'язкова
                        вимога, а більше стиль програмування.<br>
                        Що може визначати інтерфейс? В цілому інтерфейси можуть визначати такі
                        сутності:<br>
                        − методи;<br>
                        − властивості;<br>
                        − індексатори;<br>
                        − події;<br>
                        − статичні поля і константи (починаючи з версії C# 8.0).<br>
                        Однак інтерфейси не можуть визначати нестатичні змінні. Наприклад,
                        найпростіший інтерфейс, який визначає всі ці компоненти:
                    </p>
                    <img src="./photo/5_1.png" alt="">
                    <p>
                        В даному випадку визначено інтерфейс <b>IMovable</b>, який представляє певний
                        об'єкт, що рухається. Методи і властивості інтерфейсу можуть не мати реалізації, в
                        цьому вони зближуються з абстрактними методами і властивостями абстрактних
                        класів. В даному випадку інтерфейс оголошує метод <b>Move()</b>, який буде представляти
                        деяке пересування. Він не має реалізації. Те саме стосується властивості Name. Якщо
                        його члени – методи і властивості не мають модифікаторів доступу, то за
                        замовчуванням цей доступ є public, так як мета інтерфейсу − оголошення функціоналу
                        для реалізації його класом. Це стосується також і констант і статичних змінних, які в
                        класах і структурах за замовчуванням мають модифікатор private. В інтерфейсах вони
                        мають за замовчуванням модифікатор public. Наступний код визначає явно
                        модифікатори доступу в інтерфейсі.
                    </p>
                    <img src="./photo/5_2.png" alt="">
                    <h1>Застосування інтерфейсів</h1>
                    <p>
                        Не можна створювати об'єкти інтерфейсу безпосередньо за допомогою
                        конструктора, як наприклад, в класах: Інтерфейс призначений для реалізації в класах і
                        структурах. Наприклад, маючи інтерфейс <b>IMovable</b>, який-небудь клас або структура
                        можуть застосувати даний інтерфейс. Розглянемо приклад <b>task4_4</b>, в якому описаний
                        інтерфейс <b>IMovable</b> і визначений клас <b>Car</b>, похідний від інтерфейсу <b>IMovable</b>.
                    </p>
                    <img src="./photo/5_3.png" alt="">
                    <p>
                        У програмі <b>task4_4</b> визначено метод <b>Action()</b>, який в якості параметра приймає
                        об'єкт інтерфейсу <b>IMovable</b>. На момент написання коду ми можемо не знати, що це
                        буде за об'єкт - якийсь клас або структура. Єдине, в чому ми можемо бути впевнені, що
                        цей об'єкт обов'язково реалізує метод <b>Move()</b> і ми можемо викликати цей метод.
                        Іншими словами, інтерфейс – це контракт щодо обов'язкової реалізації деякого
                        функціоналу певним типом.<br>
                        Інтерфейси мають ще одну важливу функцію. C# не підтримує множинне
                        успадкування, тобто можна успадкувати клас тільки від одного базового класу.
                        Інтерфейси дозволяють частково обійти це обмеження, оскільки в C# клас може
                        реалізувати відразу кілька інтерфейсів. Усі реалізовані інтерфейси вказуються через
                        кому. Розглянемо приклад <b>task4_5</b>, в якому клас <b>Client</b> реалізує два інтерфейси.
                    </p>
                    <img src="./photo/5_4.png" alt="">
                    <img src="./photo/5_5.png" alt="">
                    <span id="t6"></span>
      <br>
      <br>
      <br>
                </section >

                    <section>
                        <h1>6. Стандартні інтерфейси NET</h1>
                        <img src="./photo/6_1.png" alt="">
                        <span id="t7"></span>
      <br>
      <br>
      <br>
                    </section >

                        <section>
                            <h1>7. Абстрактні класи</h1>
                            <p>
                                Абстрактний клас схожий на звичайний клас. Він також може мати змінні,
                                методи, конструктори, властивості. Єдине, що при визначенні абстрактних класів
                                використовується ключове слово <b>abstract</b>. Головна відмінність полягає в тому, що не
                                можна використовувати конструктор абстрактного класу для створення його об'єкта.<br>
                                Навіщо потрібні абстрактні класи? Припустимо, в програмі для банківського
                                сектора ми можемо визначити дві основні сутності: клієнт банку і співробітник банку.
                                Кожна з цих сутностей має свою специфіку, наприклад, для співробітника треба
                                визначити його посаду, а для клієнта – суму на рахунку. Відповідно клієнт і
                                співробітник становитимуть окремі класи <b>Client</b> та <b>Employee</b>. У той самий час обидві
                                ці сутності можуть мати щось спільне, наприклад, ім'я та прізвище, якусь іншу загальну
                                функціональність. І цю загальну функціональність краще винести в якийсь окремий
                                клас, наприклад, Person, який описує людину. Тобто класи <b>Employee</b> (співробітник) і
                                <b>Client</b> (клієнт банку) будуть похідними від класу <b>Person</b>. Оскільки всі об'єкти в
                                програмі представлятимуть або співробітника банку, або клієнта, безпосередньо ми від
                                класу <b>Person</b> створювати об'єкти не будемо. Тому має сенс зробити його абстрактним.
                                Розглянемо приклад <b>task4_6</b> застосування абстрактних класів.
                                </p>
                                <img src="./photo/7_1.png" alt="">
                                <img src="./photo/7_2.png" alt="">
                                <img src="./photo/7_3.png" alt="">
                                <span id="t8"></span>
      <br>
      <br>
      <br>
                        </section >

    <section class="last">  
        <h1>8. Різниця між абстрактним класом та інтерфейсом</h1>
        <p>
            Між інтерфейсами та абстрактними класами є такі відмінності:<br>
            • в інтерфейсі не можна оголошувати реалізації методів. В абстрактному класі
            допускається оголошувати реалізації його елементів;<br>
            • інтерфейс не може мати конструктори. Абстрактний клас може мати
            конструктори;<br>
            • інтерфейс не може містити поля даних. Абстрактний клас допускає
            використання внутрішніх полів даних;<br>
            • елементи інтерфейсу за замовчуванням (без модифікатора доступу)
            вважаються <b>public</b>. В абстрактних класах елементи за замовчуванням
            вважаються <b>private</b>;<br>
            • елементи інтерфейсу не повинні містити модифікатори доступу (інакше
            компілятор видасть повідомлення про помилку). В абстрактних класах
            допускається наявність будь-якого модифікатора доступу в оголошенні
            елементу класу;<br>
            • похідний клас може успадковувати тільки один абстрактний базовий клас. У
            випадку використання інтерфейсів похідний клас може успадковувати будьяку 
            кількість інтерфейсів. Таким чином, інтерфейс – це альтернатива
            абстрактного класу, з допомогою якої можна здійснити <b>множинну спадковість.</b>
        </p>
    </section>

    
</div>

<div id="page">
  <footer>
    <div class="wave">
  <svg width="516px" height="63px" viewBox="0 -1 516 63" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
      <desc>Created with Sketch.</desc>
      <defs></defs>
      <path d="M465.8994,4.8023 C446.8704,0.1653 446.8544,10.3203 432.2774,10.9823 C412.6824,11.8733 403.5104,-0.1977 386.8714,0.0033 C370.2314,-0.1977 357.0194,8.6003 357.0194,8.6003 L357.0194,8.6053 C351.2924,11.3603 345.9174,13.6933 338.4874,13.6933 C322.4554,13.6933 322.9524,8.0883 311.5974,6.3063 C300.6744,4.5933 297.4354,11.2593 286.3754,11.2593 C275.3164,11.2593 268.4204,2.9423 257.9144,2.9423 C247.4084,2.9423 227.1374,9.4693 207.9854,4.8023 C188.9564,0.1653 188.9404,10.3203 174.3634,10.9823 C154.7694,11.8733 145.5964,-0.1977 128.9574,0.0033 C112.3174,-0.1977 99.1054,8.6003 99.1054,8.6003 L99.1054,8.6053 C93.3774,11.3603 88.0034,13.6933 80.5734,13.6933 C64.5414,13.6933 65.0384,8.0883 53.6834,6.3063 C42.7604,4.5933 39.5214,11.2593 28.4614,11.2593 C17.4024,11.2593 10.5054,2.9423 0.0004,2.9423 L0.0004,61.9433 L515.8284,61.9433 L515.8284,2.9423 C505.3224,2.9423 485.0514,9.4693 465.8994,4.8023" id="Fill-1" stroke="none" fill="#E4BDB5" fill-rule="evenodd"></path>
  </svg>
  <p class="robot">©2024 Furkalo Daniil</p>
    </div>
  </footer>
  </div>


</body>
</div>
</body>
</html>