<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="../../style.css">
    <link rel="stylesheet" href="../../style_test.css">
    <link rel="stylesheet" href="Lab_1_theory.css">
    <link rel="icon" href="../../Rating/photo/logo_2.png" type="image/png">
    <title>У тебе все вийде)</title>
</head>
<body>
    <!-- Overlay for fixed sidebar -->
<div class="sidebar-overlay"></div>

<header>
    <h1>Навчайся через практику! C#</h1>
    <nav>
      <a href="../Theory/Lab_3_theory.html">Теоретичні відомості</a>
      <a href="#">Текст програми та Виконання прикладу</a>
      <a href="../example/Lab_3_example.html">Варіанти завдань</a>
      <a href="../Test/Lab_3_test.html">Контрольні запитання та література</a>
    </nav>
  </header>

<!-- navbar  -->
<div class="navbar">

  <input type="checkbox" class="checkbox" id="click" hidden>

  <!-- sidebar -->
  <div class="sidebar">
      <label for="click">
          <div class="menu-icon">
              <div class="line line-1"></div>
              <div class="line line-2"></div>
              <div class="line line-3"></div>
          </div>
          <p class="sidebar-text">Лаб 3</p>
      </label>
  </div>
  <!-- end of sidebar -->

<!--navigation-->
<nav class="navigation">
  <div class="navigation-header">
    <h1 class="navigation-heading">Робота</h1>
    
  </div>
  
  <ul class="navigation-list">
    <li class="navigation-item">
      <a href="../../Lab_1/Theory/Lab_1.html" class="navigation-link">Лабораторна робота №1</a>
    </li>
    <li class="navigation-item">
      <a href="../../Lab_2/Theory/Lab_2_theory.html" class="navigation-link">Лабораторна робота №2</a>
    </li>
    <li class="navigation-item">
      <a href="../Theory/Lab_3_theory.html" class="navigation-link">Лабораторна робота №3</a>
    </li>
    <li class="navigation-item">
      <a href="../../Lab_4/Theory/Lab_4_theory.html" class="navigation-link">Лабораторна робота №4</a>
    </li>
    <li class="navigation-item">
      <a href="../../Lab_5/Theory/Lab_5_theory.html" class="navigation-link">Лабораторна робота №5</a>
    </li>
    <li class="navigation-item">
      <a href="../../Lab_6/Theory/Lab_6_theory.html" class="navigation-link">Лабораторна робота №6</a>
    </li>
    <li class="navigation-item">
      <a href="https://docs.google.com/document/d/1ptKIyE0X2zUnQkgTMD9tHxrOsJyIKWYG3R9astTJBKA/edit" target="_blank" class="navigation-link">Теми індивідуальних творчих робіт</a>
    </li>
    <li class="navigation-item">
      <a href="../../Rating/index.html" class="navigation-link">Рейтингова система</a>
    </li>
  </ul>
</nav>
</div>
<!-- end of navbar  -->      


  <div class="wrapper">
      <section id='steezy'>
        <div class="up">
          <a class= "class_up" href="#">UP</a>
        </div>
        <h1 style="font-size: 2.4rem;">Приклади виконання завдань</h1>

        <div class="my-my-list">
          <a class ="a-list" href="#t1">Приклад 1</a><br>
          <a class ="a-list" href="#t2">Приклад 2</a><br>
          <a class ="a-list" href="#t3">Приклад 3</a><br>
          <a class ="a-list" href="#t4">Приклад 4</a><br>
          <a class ="a-list" href="#t5">Приклад 5</a><br>
        </div>
        <span id="t1"></span>
          <br>
          <br>
      <h1 style="font-size: 2rem;" id="">1. Програма розрахунку рейтингу студента. Клас Student</h1>
      <h1 style="font-size: 1.6rem;">Варіант 1. Конструктор з параметрами та створення об’єкту класу</h1>
      <p>
        Розглянемо приклад <b>task3_1</b>, в якому реалізуємо клас <b>Student</b> з відкритими
        полями і конструктором з параметрами для їх ініціалізації. Клас <b>Student</b> містить
        відкритий метод <b>public void StudentRating(int R)</b>, який виводить текст, в залежності
        від рейтингу студента. В методі <b>Main()</b> виконується тестування класу.
        Зверніть увагу, що опис класу Student розміщується в просторі імен, а не в класі
        <b>Program</b>. Опис класу Student рекомендується розмістити в окремому файлі <b>Student.cs</b>,
        тобто модулі класу. 
      </p>
          <img src="./photo/1_1.png" alt="">
          <img src="./photo/1_2.png" alt="">
      <p>
        Змінимо клас <b>Student</b>, зробимо поля <b>Name</b> i <b>Age</b> закритими, а доступ до них
        реалізуємо через властивості get і set. 
      </p>
      <h1>Варіант 2. Використання властивостей get і set замість присвоєння в конструкторі.</h1>
      <img src="./photo/1_3.png" alt="">
      <img src="./photo/1_4.png" alt="">
      <img src="./photo/1_5.png" alt="">
      <span id="t2"></span>
      <br>
      <br>
      <br>
      </section>
      
      
    <section id="">
      <h1>2. Програма автоматизованого обліку банківських відомостей</h1>
      <p>
        Розглянемо програму task3_3, що реалізує автоматизований облік банківських
        відомостей. На кожного клієнта банку зберігаються наступні відомості:<br>
        • прізвище, ім’я, по-батькові;<br>
        • дата народження;<br>
        • паспортні дані;<br>
        • ідентифікаційний код;<br>
        • місце роботи (навчання);<br>
        • номери рахунків.<br>
        Для кожного клієнта визначимо операції:<br>
        • додати нового клієнта;<br>
        • видалити клієнта;<br>
        • змінити реквізити клієнта.<br>
        На кожному рахунку зберігається інформація про поточний баланс. З кожним
        рахунком можна виконувати наступні дії:<br>
        • відкриття, закриття;<br>
        • внесення грошей, зняття грошей;<br>
        • перегляд балансу.<br>
        
        Створимо два класи. Класс <b>Client</b> для опису інформації про клієнта. Клас
        <b>Account</b> для опису банківського рахунку
      </p>

      <h1>Клас Client. Варіант 1 - конструктор без параметрів, властивості класу</h1> 
      <img src="./photo/2_1.png" alt="">
      <p>Область видимості полів класу має бути визначена або як закрита, або як
        захищена. Доступ до полів - членів класу має бути організований або за допомогою
        відкритих методів, або за допомогою властивостей класу. Створимо властивості класу
        <b>Client</b>, які забезпечують читання і запис значень закритих полів класу</p>
        <img src="./photo/2_2.png" alt="">
        <img src="./photo/2_3.png" alt="">
        <img src="./photo/2_4.png" alt="">
        <img src="./photo/2_4_4.png" alt="">
        <p>
          Як видно з прикладу, властивість складається з методів <b>set і get</b>. При цьому
          властивість повинна містити хоч би один з методів. Метод set дозволяє змінювати
          значення поля класу, <b>get</b> − отримувати значення. У метод <b>set</b> передається значення
          параметра за допомогою змінної <b>value</b>. Обидва методи можуть містити довільну
          кількість операторів, що описують алгоритм виконання дій в процесі читання або
          запису значення в полі класу. У даному прикладі властивості <b>passport</b> і name
          дозволяють просто дістати доступ до полів класу, читаючи або встановлюючи значення
          відповідних змінних. Властивість <b>birthdate</b> також призначена для читання і запису
          значення змінної - члена класу <b>BirthDate</b>. При цьому при читанні значення (операція
          <b>get</b>) відбувається просто передача значення змінної <b>BirthDate</b>, при спробі ж запису
          нового значення в цю змінну відбувається перевірка допустимості встановлюваного
          значення змінної. В даному випадку перевірка зводиться до порівняння нового
          значення дати народження з поточною датою. Якщо встановлюване значення дати
          народження більше або дорівнює поточній даті, генерується виключення, яке не
          дозволяє записати нове значення в змінну - член класу.<br>
          Властивість <b>age</b> застосовується для отримання поточного віку клієнта. Вона
          призначена лише для читання значення із змінної, тому містить лише метод <b>get</b>. При
          використанні властивості <b>age</b> відбувається обчислення поточного значення віку
          клієнта в роках шляхом віднімання року народження від поточного значення року.<br>
          Використання властивостей аналогічно використанню змінних. У наступному
          прикладі створюється об'єкт <b>с1</b> класу <b>Client</b>. Потім поля цього об'єкту заповнюються
          значеннями з використанням властивостей. Після цього на екран виводяться значення
          полів, для цього також застосовуються властивості класу:
        </p>
        <img src="./photo/2_5.png" alt="">
        <h1>Клас Client. Варіант 2 - конструктор класу з параметрами</h1>
        <p>Розглянемо конструктор класу і визначимо роль його параметрів.</p>
        <img src="./photo/2_6.png" alt="">
        <p>
          Видно, що конструктор має три параметри. У тілі конструктора відбувається
          запис переданих як параметри значень у відповідні поля класу за допомогою
          властивостей даного класу. У випадку з датою народження це дозволяє не дублювати
          процедуру перевірки введеної дати, а скористатися алгоритмом, реалізованим у
          властивості <b>birthdate</b>.<br>
          Створимо також метод, що дозволяє змінити значення полів об'єкту класу Client:
        </p>
        <img src="./photo/2_7.png" alt="">
        <p>
          Як видно з прикладу, код цього методу повністю ідентичний коду конструктору
          з параметрами з різницею в імені методу, а також в типі значення, яке повертається.
          Звичайно, в даному випадку можна було б обійтися і використанням властивостей для
          зміни значень полів класу, проте, інколи буває корисно, аби такого роду зміни були
          реалізовані в рамках одного методу, тим більше, якщо алгоритм змін є нестандартним.<br>
          Тепер, з використанням конструктора з параметрами, можна створити і відразу
          ж ініціалізувати об'єкт класу <b>Client</b>:
        </p>
        <img src="./photo/2_8.png" alt="">
        <img src="./photo/2_9.png" alt="">
        <h1>Клас Account. Варіант 1</h1>
        <p>
          У першому варіанті класу <b>Account</b> визначимо такі поля класу. Окрім двох
          основних полів <b>credit і debit</b>, які зберігають надходження і витрати рахунку, введемо
          поле <b>balance</b>, яке задає поточний стан рахунку, і два поля, пов'язані з останньою
          виконуваною операцією. Поле <b>sum</b> зберігатиме суму грошей поточної операції, а поле
          <b>result</b> – результат виконання операції. 
        </p>
        <img src="./photo/2_10.png" alt="">
        <img src="./photo/2_11.png" alt="">
        <p>
          Як можна бачити, лише у методів <b>getMoney()</b> і <b>putMoney()</b> класу <b>Account </b> є один
          вхідний аргумент, що визначає суму грошей, з якою працює клієнт. Лише клієнт може
          вирішити, яку суму він хоче зняти або покласти на рахунок. Інших аргументів в
          методах класу <b>Account</b> немає − вся інформація передається через поля класу.
          Зменшення кількості аргументів приводить до підвищення ефективності роботи з
          методами, оскільки зникають витрати на передачу фактичних значень аргументів. Але
          при цьому ускладнюються операції роботи з вкладом, оскільки потрібно в момент
          виконання операції оновлювати значення полів класу. Закритий метод <b>Message()</b> 
          викликається після виконання кожної операції, повідомляючи про те, як пройшла
          операція, і інформуючи клієнта про поточний стан його балансу
        </p>
        <h1>Клас Account. Варіант 2</h1>
        <p>
          Спроектуємо аналогічний клас <b>Account1</b>, який відрізняється лише тим, що у
          нього буде менше полів. Замість поля <b>balance</b> в класі з'явиться відповідний метод з
          таким самим іменем, замість полів <b>sum і result</b> з'являться аргументи в методах, що
          забезпечують необхідну передачу інформації. Опис класу може бути такий.
        </p>
        <img src="./photo/2_12.png" alt="">
        <img src="./photo/2_13.png" alt="">
        <img src="./photo/2_14.png" alt="">
        <p>
          Порівнюючи опис класу <b>Account1</b> з описом класу <b>Account</b>, можна побачити, що
          кількість полів скоротилося з п'яти до двох, спростилися основні методи <b>getMoney()</b> і
          <b>putMoney()</b>. Але в класі <b>Account1</b> з'явився додатковий метод <b>balance()</b>, що багато разів
          викликається, і в методі <b>Message()</b> з'явилися два аргументи. Який клас кращий?
          Однозначно сказати не можна, все залежить від контексту, від пріоритетів, заданих при
          створенні конкретної системи.<br>
          Для тестування роботи з класами <b>Account1</b> і <b>Account</b> використовується метод
          <b>TestAccounts()</b> класу <b>Program</b>, що викликається в методі <b>Main()</b>:
        </p>
        <img src="./photo/2_15.png" alt="">
        <img src="./photo/2_16.png" alt="">
        <span id="t3"></span>
      <br>
      <br>
      <br>
    </section >

    <section id="">
      <h1>3. Вбудовані (вкладені) класи</h1>
      <p>
        У мові C# будь-який клас у своїй реалізації може містити оголошення іншого
        класу. Клас, що оголошується в межах іншого класу, тобто в межах фігурних дужок,
        що обмежують опис класу, називається вкладеним класом. Вкладені класи можуть
        мати модифікатори доступу <b>public, protected, internal, protected internal, private</b> або
        <b>private protected</b>. Об`єкт вкладеного класу можна оголосити у випадку, якщо
        вкладений клас оголошений як видимий (не як private).<br>
        Розглянемо приклад <b>task3_5</b>. Нехай Book – ім’я класу, який містить в собі
        оголошення іншого класу з іменем <b>Price</b>. Якщо вкладений клас оголошено не як
        закритий <b>private</b>-клас, створення екземпляру цього класу має вигляд:
        <b>Book.Price obj = new Book.Price();</b><br>
        Код прикладу <b>task3_5</b> може бути такий.
      </p>
      <img src="./photo/3_1.png" alt="">
      <span id="t4"></span>
      <br>
      <br>
      <br>
    </section >

    <section>
      <h1>4. Часткові класи (класи, що розділяються) і часткові методи</h1>
      <p>Класи можуть бути частковими. Тобто ми можемо мати кілька файлів з
        визначенням одного і того самого класу, і при компіляції всі ці визначення будуть
        скомпільовані в одне. Наприклад, визначимо в проекті <b>task3_6</b> два файли для класу
        <b>Person</b> з кодом.</p>
        <img src="./photo/4_1.png" alt="">
        <p>
          Отже, два файли в проекті містить визначення одного і того самого класу <b>Person</b>,
          які містять два різних методи. Обидва визначені класи є <b>частковими</b>. Для цього вони
          визначаються з ключовим словом <b>partial</b>. Ключове слово <b>partial</b> вказує, що інші
          частини класу, структури або інтерфейсу можуть бути визначені в просторі імен. Усі
          частини класу повинні використовувати ключове слово <b>partial</b>. Для формування
          остаточного класу всі частини повинні бути доступні під час компіляції. Всі частини
          повинні мати однакові модифікатори доступу, наприклад <b>public, private</b> тощо.<br>
          Протестуємо використання методів часткових класів, викликаючи їх в методі
          <b>Main()</b>.
        </p>
        <img src="./photo/4_2.png" alt="">
        <p>
          Часткові класи можуть містити часткові методи. Такі методи також
          визначаються з ключовим словом <b>partial</b>. Причому визначення часткового методу без
          тіла методу знаходиться в одному частковому класі, а реалізація цього самого методу
          – в іншому частковому класі..
        </p>
        <img src="./photo/4_3.png" alt="">
        <img src="./photo/4_4.png" alt="">
        <span id="t5"></span>
      <br>
      <br>
      <br>
    </section >
        
    <section class="last" >  
      <h1>5. Текстові файли</h1>
        
        <p>В С# для роботи з файлами і потоками використовуються класи <b>FileStream StreamWriter, StreamReader, FileInfo</b>,
           та інші класи.<br>
          Для введення і виведення даних не потоками, а рядками призначені класи
          <b>StringReader, StringWriter</b>.<br>
          Розглянемо приклад <b>task3_7</b>. В цьому прикладі спочатку створюється об'єкт <b>fout</b>
          класу <b>StreamWriter</b>, який визначає файл для виведення <b>output.txt</b>. Якщо не вказати
          повний шлях до файлу, файл буде створений в директорії, де розміщується exe-файл
          програми: ...\\bin\\debug\\output.txt<br>
          Далі визначаються і ініціалізуються змінні <b>int i</b> та <b>string s</b>, значення яких
          записуються у вихідний файл <b>output.txt</b>. Метод <b>Close()</b> закриває файл. В другій частині
          прикладу <b>task3_7</b> по черзі зчитаються рядки з файлу <b>input.txt</b>, перетворюються у
          числові типи і виводяться на консоль. Файл <b>input.txt</b> створений в текстовому редакторі
          і використовується тільки для читання.
        </p>
        <img src="./photo/5_1.png" alt="">
        <img src="./photo/5_2.png" alt="">
    </section>

    
</div>

<div id="page">
  <footer>
    <div class="wave">
  <svg width="516px" height="63px" viewBox="0 -1 516 63" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
      <desc>Created with Sketch.</desc>
      <defs></defs>
      <path d="M465.8994,4.8023 C446.8704,0.1653 446.8544,10.3203 432.2774,10.9823 C412.6824,11.8733 403.5104,-0.1977 386.8714,0.0033 C370.2314,-0.1977 357.0194,8.6003 357.0194,8.6003 L357.0194,8.6053 C351.2924,11.3603 345.9174,13.6933 338.4874,13.6933 C322.4554,13.6933 322.9524,8.0883 311.5974,6.3063 C300.6744,4.5933 297.4354,11.2593 286.3754,11.2593 C275.3164,11.2593 268.4204,2.9423 257.9144,2.9423 C247.4084,2.9423 227.1374,9.4693 207.9854,4.8023 C188.9564,0.1653 188.9404,10.3203 174.3634,10.9823 C154.7694,11.8733 145.5964,-0.1977 128.9574,0.0033 C112.3174,-0.1977 99.1054,8.6003 99.1054,8.6003 L99.1054,8.6053 C93.3774,11.3603 88.0034,13.6933 80.5734,13.6933 C64.5414,13.6933 65.0384,8.0883 53.6834,6.3063 C42.7604,4.5933 39.5214,11.2593 28.4614,11.2593 C17.4024,11.2593 10.5054,2.9423 0.0004,2.9423 L0.0004,61.9433 L515.8284,61.9433 L515.8284,2.9423 C505.3224,2.9423 485.0514,9.4693 465.8994,4.8023" id="Fill-1" stroke="none" fill="#E4BDB5" fill-rule="evenodd"></path>
  </svg>
  <p class="robot">©2024 Furkalo Daniil</p>
    </div>
  </footer>
  </div>


</body>
</div>
</body>
</html>